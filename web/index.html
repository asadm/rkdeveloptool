<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>rkdeveloptool Flash Helper</title>
  <link rel="stylesheet" href="https://unpkg.com/98.css" />
  <style>
    :root {
      --win98-bg: #008080;
    }
    * {
      box-sizing: border-box;
    }
    body {
      margin: 0;
      min-height: 100vh;
      background: var(--win98-bg);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 16px;
      font-family: "MS Sans Serif", "Microsoft Sans Serif", Arial, sans-serif;
    }
    .wizard-window {
      width: 860px;
      max-width: calc(100vw - 20px);
    }
    .wizard-body {
      display: grid;
      grid-template-columns: 220px 1fr;
      gap: 12px;
      align-items: start;
    }
    .wizard-steps {
      padding: 12px;
    }
    .wizard-steps h4 {
      margin: 0 0 8px;
      font-size: 14px;
    }
    .wizard-steps ol {
      margin: 0;
      padding-left: 18px;
    }
    .wizard-steps li {
      margin-bottom: 8px;
    }
    .wizard-steps li.active {
      font-weight: bold;
      text-decoration: underline;
    }
    .wizard-steps li.done {
      font-weight: bold;
    }
    .wizard-steps li.done::before {
      content: "✓ ";
      color: #006400;
    }
    .success-banner {
      margin-top: 8px;
      background: #dff0d8;
      border: 1px solid #7db26c;
      padding: 8px;
      display: none;
    }
    .success-banner.show {
      display: block;
    }
    fieldset {
      margin: 0 0 12px;
    }
    legend {
      font-weight: bold;
    }
    .dropzone {
      cursor: pointer;
      text-align: center;
      min-height: 120px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #fff;
    }
    .dropzone:hover {
      background: #e5e5e5;
    }
    .dropzone.active {
      background: #d6d6d6;
    }
    .progress-row {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .progress-indicator {
      flex: 1;
    }
    #progress-label {
      min-width: 160px;
    }
    #progress-steps {
      margin: 8px 0 0;
      padding-left: 18px;
      max-height: 140px;
      overflow: auto;
    }
    #progress-steps li {
      margin-bottom: 4px;
    }
    #progress-steps li.done::before {
      content: "• ";
      font-weight: bold;
    }
    .log-panel {
      padding: 0;
    }
    #output {
      margin: 0;
      padding: 12px;
      white-space: pre-wrap;
      background: #fff;
      max-height: 240px;
      overflow: auto;
    }
    .file-list {
      font-family: monospace;
      white-space: pre-wrap;
    }
    .status-text {
      color: #333;
    }
    .top-actions {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }
    .wizard-step {
      margin: 0 0 12px;
    }
    .wizard-step.hidden {
      display: none;
    }
    .wizard-nav {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      margin-top: 4px;
    }
    .wizard-nav-right {
      display: flex;
      gap: 8px;
    }
    @media (max-width: 760px) {
      body {
        align-items: flex-start;
      }
      .wizard-body {
        grid-template-columns: 1fr;
      }
      .wizard-window {
        width: 100%;
      }
    }
  </style>
</head>
<body>
  <div class="window wizard-window">
    <div class="title-bar">
      <div class="title-bar-text">rkdeveloptool Flash Wizard</div>
      <div class="title-bar-controls">
        <button aria-label="Minimize"></button>
        <button aria-label="Maximize"></button>
        <button aria-label="Close"></button>
      </div>
    </div>
    <div class="window-body">
      <div class="wizard-body">
        <aside class="sunken-panel wizard-steps">
          <h4>Setup wizard</h4>
          <ol id="step-list">
            <li data-step="permission">Connect to device</li>
            <li data-step="files">Drop images</li>
            <li data-step="flash">Flash progress</li>
          </ol>
        </aside>
        <div class="wizard-main">
          <fieldset class="wizard-step" data-step="permission">
            <legend>1. Connect</legend>
            <p class="status-text" id="connect-status">Waiting for USB permission…</p>
            <div class="field-row top-actions">
              <button id="wiz-device-btn">Select device (Maskrom/Loader)</button>
              <button id="list-btn">List devices</button>
            </div>
          </fieldset>

          <fieldset class="wizard-step hidden" data-step="files">
            <legend>2. Add images</legend>
            <p class="status-text" id="file-status">Drop images or choose them manually.</p>
            <div id="dropzone" class="field-border dropzone">
              <p>Drop files here or select: <input type="file" id="file-input" multiple></p>
            </div>
            <div class="field-border" style="margin-top: 8px;">
              <strong>Files:</strong>
              <div id="files" class="file-list"></div>
            </div>
          </fieldset>

          <fieldset class="wizard-step hidden" data-step="flash">
            <legend>3. Flash</legend>
            <div class="field-row top-actions">
              <button class="default" id="wiz-flash-btn">Flash device</button>
              <button id="parse-btn">Parse mtdparts</button>
              <button id="info-btn">Read flash info</button>
            </div>
            <div class="progress-row" style="margin-top: 8px;">
              <span id="progress-label">Waiting…</span>
              <div class="progress-indicator segmented">
                <span class="progress-indicator-bar" id="progress-bar" style="width: 0%;"></span>
              </div>
            </div>
            <ol id="progress-steps" class="sunken-panel" style="padding: 8px 12px; margin-top: 8px;"></ol>
            <div class="field-row top-actions" style="justify-content: flex-end; margin-top: 8px;">
              <button class="default" id="wiz-flash-btn-bottom">Flash device</button>
              <button id="parse-btn-bottom">Parse mtdparts</button>
              <button id="info-btn-bottom">Read flash info</button>
            </div>
            <div id="success-banner" class="success-banner">
              Flash complete! <button id="restart-btn">Start over</button>
            </div>
          </fieldset>

          <details id="advanced" style="margin-top: 0.5rem;">
            <summary>Advanced controls</summary>
            <div class="field-row" style="margin-top: 0.5rem; flex-wrap: wrap; gap: 8px;">
              <button id="request-btn">Grant USB access</button>
              <button id="load-btn">Load loader</button>
              <button id="flash-btn">Flash partitions</button>
              <button id="reset-btn">Reset device</button>
            </div>
          </details>

          <div class="sunken-panel log-panel" style="margin-top: 12px;">
            <div class="status-field-border" style="padding: 4px 8px; background: #c0c0c0;">
              Wizard output
            </div>
            <pre id="output">Waiting…</pre>
          </div>
          <div class="wizard-nav">
            <button id="back-btn">Back</button>
            <div class="wizard-nav-right">
              <button id="next-btn">Next</button>
              <button class="default" id="start-btn">Start flash</button>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script type="module">
    import createModule from './rkDevelopTool_Mac.js';

    const output = document.getElementById('output');
    const filesDiv = document.getElementById('files');
    const progressBar = document.getElementById('progress-bar');
    const progressLabel = document.getElementById('progress-label');
    const progressSteps = document.getElementById('progress-steps');
    const stepList = document.getElementById('step-list');
    const connectStatus = document.getElementById('connect-status');
    const fileStatus = document.getElementById('file-status');
    const backBtn = document.getElementById('back-btn');
    const nextBtn = document.getElementById('next-btn');
    const startBtn = document.getElementById('start-btn');
    const wizFlashBtnBottom = document.getElementById('wiz-flash-btn-bottom');
    const parseBtnBottom = document.getElementById('parse-btn-bottom');
    const infoBtnBottom = document.getElementById('info-btn-bottom');
    const successBanner = document.getElementById('success-banner');
    const restartBtn = document.getElementById('restart-btn');
    const wizardSteps = document.querySelectorAll('.wizard-step');
    const modulePromise = createModule({
      noInitialRun: true,
      locateFile: (path) => path.endsWith('.wasm') ? './rkDevelopTool_Mac.wasm' : path
    });

    const requiredImgs = ['env', 'idblock', 'uboot', 'boot', 'oem', 'userdata', 'rootfs'];

    let fileMap = new Map(); // name -> File
    let cachedParts = null;
    let cachedLoader = null;
    let cachedLoaderName = '';
    let wizardPermission = false;
    let progressTotal = 1;
    let progressDone = 0;
    let currentStepIdx = 0;
    const stepOrder = ['permission', 'files', 'flash'];
    const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

    const log = (msg) => {
      output.textContent = msg;
      console.log(msg);
      scrollLogs();
    };
    const append = (msg) => {
      output.textContent += '\n' + msg;
      console.log(msg);
      scrollLogs();
    };

    function setStepDone(step, done = true) {
      const el = stepList?.querySelector(`[data-step="${step}"]`);
      if (el) el.classList.toggle('done', done);
    }

    function setStepActive(step) {
      stepList?.querySelectorAll('li').forEach((li) => {
        li.classList.toggle('active', li.dataset.step === step);
      });
    }

    function showStep(idx) {
      currentStepIdx = Math.min(Math.max(idx, 0), stepOrder.length - 1);
      wizardSteps.forEach((el, i) => {
        el.classList.toggle('hidden', i !== currentStepIdx);
      });
      setStepActive(stepOrder[currentStepIdx]);
      updateNavButtons();
    }

    function updateConnectStatus(text, done = false) {
      if (connectStatus) connectStatus.textContent = text;
      setStepDone('permission', done);
      updateNavButtons();
    }

    function updateFileStatus() {
      if (fileStatus) {
        if (fileMap.size) {
          fileStatus.textContent = `${fileMap.size} file(s) ready.`;
          setStepDone('files', true);
        } else {
          fileStatus.textContent = 'Drop images or choose them manually.';
          setStepDone('files', false);
        }
      }
      updateNavButtons();
    }

    function resetProgress(total = 1, label = 'Waiting…') {
      progressTotal = Math.max(1, total);
      progressDone = 0;
      if (progressBar) progressBar.style.width = '0%';
      if (progressLabel) progressLabel.textContent = label;
      if (progressSteps) progressSteps.innerHTML = '';
      if (successBanner) successBanner.classList.remove('show');
    }

    function bumpTotalSteps(extra = 1) {
      progressTotal = Math.max(1, progressTotal + extra);
    }

    function completeProgress(label) {
      progressDone += 1;
      const pct = Math.min(100, Math.round((progressDone / progressTotal) * 100));
      if (progressBar) progressBar.style.width = `${pct}%`;
      if (progressLabel) progressLabel.textContent = label || `${pct}% complete`;
      if (progressSteps) {
        const li = document.createElement('li');
        li.textContent = label || `Step ${progressDone}`;
        li.classList.add('done');
        progressSteps.appendChild(li);
      }
      scrollLogs();
    }

    function normalizeName(file) {
      const base = file.name.toLowerCase();
      return base;
    }

    function refreshFileList() {
      const lines = [];
      for (const [name, f] of fileMap.entries()) {
        lines.push(`${name} (${f.size} bytes)`);
      }
      filesDiv.textContent = lines.join('\n');
      updateFileStatus();
    }

    function addFiles(fileList) {
      for (const f of fileList) {
        fileMap.set(normalizeName(f), f);
      }
      refreshFileList();
    }

    async function readFileAsUint8Array(file) {
      const buf = await file.arrayBuffer();
      return new Uint8Array(buf);
    }

    function parseSize(numStr, unit) {
      const n = parseInt(numStr, 10);
      const u = unit ? unit.toUpperCase() : '';
      if (u === 'G') return n * 1024 * 1024 * 1024;
      if (u === 'M') return n * 1024 * 1024;
      if (u === 'K') return n * 1024;
      return n;
    }

    function findMtdpartsString(data) {
      // Decode as Latin-1 to preserve byte-for-byte text without dropping high-bit chars.
      const raw = new TextDecoder('latin1', { fatal: false }).decode(data);
      let m = raw.match(/(?:mtdparts|blkdevparts)=[^\s\x00"']+/i);
      if (m) {
        const off = raw.toLowerCase().search(/(?:mtdparts|blkdevparts)/);
        console.log('Found mtd/blkdev parts (latin1) at offset', off);
        return m[0];
      }
      console.log('latin1 scan: no mtdparts');
      // Fallback: UTF-16LE in case the string is wide.
      const dv = new DataView(data.buffer, data.byteOffset, data.byteLength);
      let utf16 = '';
      for (let i = 0; i + 1 < data.length; i += 2) {
        const code = dv.getUint16(i, true);
        utf16 += (code >= 0x20 && code <= 0x7e) ? String.fromCharCode(code) : ' ';
      }
      m = utf16.match(/(?:mtdparts|blkdevparts)=[^\s"]+/i);
      if (m) {
        console.log('Found mtd/blkdev parts (utf16le)');
        return m[0];
      }
      console.log('UTF16 scan: no mtdparts');
      return null;
    }

    function parseMtdparts(str) {
      const m = str.match(/(?:mtdparts|blkdevparts)=([^\s]+)/i);
      if (!m) return null;
      const spec = m[1];
      const colon = spec.indexOf(':');
      if (colon === -1) return null;
      const partsSpec = spec.slice(colon + 1);
      const entries = partsSpec.split(',');
      const partitions = [];
      let currentOffset = 0;
      for (const entry of entries) {
        const match = entry.match(/([0-9]+)([KMG]?)(?:@([0-9]+)([KMG]?))?\(([^)]+)\)/i);
        if (!match) continue;
        const sizeBytes = parseSize(match[1], match[2]);
        const hasOffset = typeof match[3] !== 'undefined' && match[3] !== '';
        const offsetBytes = hasOffset ? parseSize(match[3], match[4]) : currentOffset;
        const name = match[5];
        const startLba = Math.floor(offsetBytes / 512);
        const sizeLba = Math.floor((sizeBytes + 511) / 512);
        partitions.push({ name, startLba, sizeLba });
        currentOffset = Math.max(currentOffset, offsetBytes + sizeBytes);
      }
      return partitions;
    }

    async function extractPartitions() {
      const envFile = [...fileMap.values()].find(f => normalizeName(f).includes('env'));
      if (!envFile) throw new Error('env.img not provided.');
      const data = await readFileAsUint8Array(envFile);
      console.log(`Scanning ${envFile.name} (${data.length} bytes) for mtdparts`);
      const mtdpartsStr = findMtdpartsString(data);
      if (mtdpartsStr) {
        const parts = parseMtdparts(mtdpartsStr);
        if (parts && parts.length) {
          append(`Found mtdparts in ${envFile.name}`);
          return parts;
        }
      }
      return null;
    }

    function findLoader() {
      const binFiles = [...fileMap.values()].filter(f => f.name.toLowerCase().endsWith('.bin'));
      return binFiles[0] || null;
    }

    async function ensureLoaderBuffer() {
      if (cachedLoader) return { data: cachedLoader, name: cachedLoaderName };
      const loader = findLoader();
      if (!loader) throw new Error('Missing loader (.bin)');
      cachedLoaderName = loader.name;
      cachedLoader = await readFileAsUint8Array(loader);
      return { data: cachedLoader, name: cachedLoaderName };
    }

    function findImageForName(name) {
      const lower = name.toLowerCase();
      for (const [key, f] of fileMap.entries()) {
        if (key.includes(`${lower}.img`)) return f;
        if (key === `${lower}`) return f;
      }
      return null;
    }

    async function ensureParts() {
      if (cachedParts) return cachedParts;
      const parts = await extractPartitions();
      if (!parts) throw new Error('Failed to locate mtdparts in provided files.');
      cachedParts = parts;
      return parts;
    }

    async function listDevicesAndLog(Module) {
      try {
        const raw = await Module.listDevicesJs();
        const devices = Array.from(raw || []);
        if (!devices.length) {
          log('No Rockchip devices found (ensure permission).');
          return;
        }
        const lines = devices.map(d => `DevNo=${d.devNo} Vid=0x${d.vid.toString(16)} Pid=0x${d.pid.toString(16)} LocationID=${d.locationId} ${d.type}`);
        log(lines.join('\n'));
        const first = devices[0];
        if (first && connectStatus) connectStatus.textContent = `Detected device: ${first.type} (Vid=0x${first.vid.toString(16)}, Pid=0x${first.pid.toString(16)})`;
      } catch (err) {
        log(`Error: ${err}`);
      }
    }

    function canAdvanceFrom(step) {
      if (step === 'permission') return wizardPermission;
      if (step === 'files') return fileMap.size > 0;
      return true;
    }

    function updateNavButtons() {
      const atFirst = currentStepIdx === 0;
      const atLast = currentStepIdx === stepOrder.length - 1;
      const currentStep = stepOrder[currentStepIdx];
      if (backBtn) backBtn.disabled = atFirst;
      if (nextBtn) {
        nextBtn.disabled = atLast || !canAdvanceFrom(currentStep);
        nextBtn.hidden = currentStep === 'files';
      }
      if (startBtn) startBtn.disabled = !canAdvanceFrom('files');
    }

    function goNext() {
      const currentStep = stepOrder[currentStepIdx];
      if (!canAdvanceFrom(currentStep)) return;
      if (currentStepIdx < stepOrder.length - 1) {
        showStep(currentStepIdx + 1);
      }
    }

    function goBack() {
      if (currentStepIdx > 0) {
        showStep(currentStepIdx - 1);
      }
    }

    function setFlashControlsEnabled(enabled) {
      const ids = [
        'wiz-flash-btn',
        'parse-btn',
        'info-btn',
        'wiz-flash-btn-bottom',
        'parse-btn-bottom',
        'info-btn-bottom',
        'start-btn',
        'next-btn',
        'back-btn'
      ];
      ids.forEach((id) => {
        const btn = document.getElementById(id);
        if (btn) btn.disabled = !enabled;
      });
    }

    function scrollLogs() {
      if (output) output.scrollTop = output.scrollHeight;
      if (progressSteps) progressSteps.scrollTop = progressSteps.scrollHeight;
    }

    async function waitForDevice(Module, allowed = ['loader', 'maskrom'], retries = 12, delayMs = 500) {
      for (let i = 0; i < retries; i++) {
        try {
          const raw = await Module.listDevicesJs();
          const devices = Array.from(raw || []);
          const loader = devices.find((d) => allowed.includes((d.type || '').toLowerCase()));
          if (loader) return loader;
        } catch (_) {}
        await sleep(delayMs);
      }
      return false;
    }

    async function eraseFlashWithLog(Module) {
      append('Erasing flash…');
      try {
        const ok = await Module.eraseFlash();
        if (!ok) {
          log('Erase flash failed. Aborting.');
          return false;
        }
        append('Erase flash complete.');
        return true;
      } catch (err) {
        log(`Erase flash error: ${err?.message || err}. Aborting.`);
        return false;
      }
    }

    async function ensureUsbPermission() {
      try {
        const allowed = await navigator.usb.getDevices();
        if (allowed.some(d => d.vendorId === 0x2207 || d.vendorId === 0x071B)) {
          wizardPermission = true;
          updateConnectStatus('Permission already granted.', true);
          return true;
        }
      } catch (_) {}
      try {
        await navigator.usb.requestDevice({ filters: [{ vendorId: 0x2207 }, { vendorId: 0x071B }] });
        wizardPermission = true;
        updateConnectStatus('Permission granted.', true);
        return true;
      } catch (err) {
        const msg = `Permission denied or error: ${err.message || err}`;
        log(msg);
        updateConnectStatus(msg, false);
        return false;
      }
    }

    async function flashWizard() {
      log('Starting flash wizard…');
      setStepDone('flash', false);
      const Module = await modulePromise;

      let parts;
      try {
        parts = await ensureParts();
      } catch (err) {
        log(err.message || String(err));
        return;
      }
      const needed = requiredImgs.filter(n => parts.find(p => p.name.toLowerCase() === n));
      const totalSteps = 6 + needed.length + 1; // permission, parse, validate, loader ready, read info, erase, per part, reset
      resetProgress(totalSteps, 'Starting…');
      completeProgress('Parsed mtdparts');

      const okPerm = await ensureUsbPermission();
      if (!okPerm) {
        if (progressLabel) progressLabel.textContent = 'USB permission required.';
        return;
      }
      completeProgress('USB permission granted');

      const missing = [];
      for (const r of requiredImgs) {
        if (!findImageForName(r)) missing.push(r);
      }
      if (missing.length) {
        log(`Missing required images: ${missing.join(', ')}`);
        if (progressLabel) progressLabel.textContent = 'Add required images.';
        return;
      }
      completeProgress('Images validated');

      let loaderBuf;
      let loaderName;
      try {
        const loader = await ensureLoaderBuffer();
        loaderBuf = loader.data;
        loaderName = loader.name;
        completeProgress('Loader ready');
      } catch (err) {
        log(err.message || String(err));
        return;
      }

      let info;
      try {
        info = await Module.readFlashInfo();
        if (!info || info.flashSizeMiB === undefined) {
          bumpTotalSteps(1);
          append('ReadFlashInfo empty; attempting to load loader…');
          append(`Loading loader ${loaderName}…`);
          const dlOk = await Module.downloadBootBuffer(loaderBuf);
          if (!dlOk) {
            log('downloadBoot failed. Aborting.');
            return;
          }
          completeProgress(`Loader ${loaderName} downloaded`);
          append('Loader loaded, waiting for device to enumerate…');
          const dev = await waitForDevice(Module, ['loader', 'maskrom'], 20, 500);
          if (!dev) {
            log('Loader loaded but device not detected.');
            return;
          }
          append(`Device present (${dev.type}).`);
          info = await Module.readFlashInfo();
        }
        if (info && info.flashSizeMiB !== undefined) {
          append(`FlashInfo: manufacturer=${info.manufacturer} size=${info.flashSizeMiB}MiB`);
        } else {
          log('ReadFlashInfo returned empty result. Aborting.');
          return;
        }
      } catch (err) {
        log(`ReadFlashInfo failed (${err?.message || err}). Aborting.`);
        return;
      }
      completeProgress('Flash info read');

      const erased = await eraseFlashWithLog(Module);
      if (!erased) return;
      completeProgress('Erase flash complete');

      for (const part of parts) {
        const nameLower = part.name.toLowerCase();
        const f = findImageForName(nameLower);
        if (!f) {
          append(`Skipping ${part.name} (no matching image).`);
          continue;
        }
        if (!needed.includes(nameLower)) {
          append(`Skipping ${part.name} (not in required list).`);
          continue;
        }
        const data = await readFileAsUint8Array(f);
        append(`Writing ${part.name} (${data.byteLength} bytes) @ LBA ${part.startLba}…`);
        try {
          const ok = await Module.writeLba(part.startLba, data);
          if (!ok) {
            log(`WriteLBA failed for ${part.name}. Aborting.`);
            return;
          }
        } catch (err) {
          log(`WriteLBA threw for ${part.name}: ${err?.message || err}. Aborting.`);
          return;
        }
        completeProgress(`Flashed ${part.name}`);
      }

      append('Issuing reset…');
      try {
        const ok = await Module.resetDevice(0);
        append(ok ? 'ResetDevice sent.' : 'ResetDevice failed.');
      } catch (err) {
        append(`ResetDevice error: ${err}`);
      }
      completeProgress('Reset sent');
      setStepDone('flash', true);
      if (progressLabel) progressLabel.textContent = 'All steps complete';
      append('Flash sequence complete.');
      if (successBanner) successBanner.classList.add('show');
    }

    async function flashAll() {
      log('Loading WASM…');
      const Module = await modulePromise;

      // Validate files
      const missing = [];
      for (const r of requiredImgs) {
        if (!findImageForName(r)) missing.push(r);
      }
      if (missing.length) {
        log(`Missing required images: ${missing.join(', ')}`);
        return;
      }
      let parts;
      try {
        parts = await ensureParts();
      } catch (err) {
        log(err.message || String(err));
        return;
      }
      const needed = requiredImgs.filter(n => parts.find(p => p.name.toLowerCase() === n));
      append(`Found mtdparts: ${parts.map(p => `${p.name}@${p.startLba}`).join(', ')}`);

      // Require an already-loaded device (loader or maskrom)
      const dev = await waitForDevice(Module, ['loader', 'maskrom'], 20, 500);
      if (!dev) {
        log('No Loader/Maskrom device detected. Load the loader first.');
        return;
      }
      append(`Using detected device (${dev.type}).`);

      // Probe flash info (mandatory)
      try {
        const info = await Module.readFlashInfo();
        if (info && info.flashSizeMiB !== undefined) {
          append(`FlashInfo: manufacturer=${info.manufacturer} size=${info.flashSizeMiB}MiB`);
        } else {
          log('ReadFlashInfo returned empty result. Aborting.');
          return;
        }
      } catch (err) {
        log(`ReadFlashInfo failed (${err?.message || err}). Aborting.`);
        return;
      }

      const erased = await eraseFlashWithLog(Module);
      if (!erased) return;

      // Flash partitions
      for (const part of parts) {
        const nameLower = part.name.toLowerCase();
        const f = findImageForName(nameLower);
        if (!f) {
          append(`Skipping ${part.name} (no matching image).`);
          continue;
        }
        if (!needed.includes(nameLower)) {
          append(`Skipping ${part.name} (not in required list).`);
          continue;
        }
        const data = await readFileAsUint8Array(f);
        append(`Writing ${part.name} (${data.byteLength} bytes) @ LBA ${part.startLba}…`);
        try {
          const ok = await Module.writeLba(part.startLba, data);
          if (!ok) {
            log(`WriteLBA failed for ${part.name}. Aborting.`);
            return;
          }
        } catch (err) {
          log(`WriteLBA threw for ${part.name}: ${err?.message || err}. Aborting.`);
          return;
        }
      }

      // Reset
      append('Issuing reset…');
      try {
        const ok = await Module.resetDevice(0);
        append(ok ? 'ResetDevice sent.' : 'ResetDevice failed.');
      } catch (err) {
        append(`ResetDevice error: ${err}`);
      }
      append('Flash sequence complete.');
    }

    document.getElementById('wiz-device-btn').addEventListener('click', async () => {
      const ok = await ensureUsbPermission();
      if (!ok) return;
      const Module = await modulePromise;
      await listDevicesAndLog(Module);
      showStep(stepOrder.indexOf('files'));
    });

    document.getElementById('wiz-flash-btn').addEventListener('click', () => {
      setFlashControlsEnabled(false);
      flashWizard().catch(err => {
        log(`Error: ${err.message || err}`);
      }).finally(() => {
        if (!successBanner?.classList.contains('show')) setFlashControlsEnabled(true);
      });
    });

    document.getElementById('request-btn').addEventListener('click', async () => {
      try {
        await navigator.usb.requestDevice({ filters: [{ vendorId: 0x2207 }, { vendorId: 0x071B }] });
        updateConnectStatus('Permission granted.', true);
        log('Permission granted (or already granted).');
      } catch (err) {
        const msg = `Permission denied or error: ${err.message || err}`;
        updateConnectStatus(msg, false);
        log(msg);
      }
    });

    document.getElementById('list-btn').addEventListener('click', async () => {
      log('Loading WASM…');
      const Module = await modulePromise;
      await listDevicesAndLog(Module);
    });

    document.getElementById('flash-btn').addEventListener('click', () => {
      flashAll().catch(err => {
        log(`Error: ${err.message || err}`);
      });
    });

    document.getElementById('parse-btn').addEventListener('click', async () => {
      try {
        const parts = await ensureParts();
        log(`Parsed mtdparts: ${parts.map(p => `${p.name}@${p.startLba}`).join(', ')}`);
      } catch (err) {
        log(`Parse failed: ${err.message || err}`);
      }
    });

    document.getElementById('load-btn').addEventListener('click', async () => {
      log('Loading WASM…');
      const Module = await modulePromise;
      try {
        const loader = await ensureLoaderBuffer();
        append(`Loading loader ${loader.name}…`);
        const ok = await Module.downloadBootBuffer(loader.data);
        if (!ok) {
          log('Loader load failed.');
          return;
        }
        const dev = await waitForDevice(Module, ['loader', 'maskrom'], 20, 500);
        log(dev ? `Device present (${dev.type}).` : 'Loader loaded but device not detected.');
      } catch (err) {
        log(err.message || String(err));
      }
    });

    document.getElementById('info-btn').addEventListener('click', async () => {
      log('Loading WASM…');
      const Module = await modulePromise;
      try {
        const info = await Module.readFlashInfo();
        if (info && info.flashSizeMiB !== undefined) {
          log(`FlashInfo: manufacturer=${info.manufacturer} size=${info.flashSizeMiB}MiB`);
        } else {
          log('ReadFlashInfo returned empty result.');
        }
      } catch (err) {
        log(`ReadFlashInfo failed: ${err.message || err}`);
      }
    });

    document.getElementById('reset-btn').addEventListener('click', async () => {
      log('Loading WASM…');
      const Module = await modulePromise;
      try {
        const ok = await Module.resetDevice(0);
        log(ok ? 'ResetDevice sent.' : 'ResetDevice failed.');
      } catch (err) {
        log(`ResetDevice failed: ${err.message || err}`);
      }
    });

    const dropzone = document.getElementById('dropzone');
    dropzone.addEventListener('dragover', (e) => {
      e.preventDefault();
      dropzone.classList.add('active');
    });
    dropzone.addEventListener('dragleave', (e) => {
      e.preventDefault();
      dropzone.classList.remove('active');
    });
    dropzone.addEventListener('drop', (e) => {
      e.preventDefault();
      dropzone.classList.remove('active');
      if (e.dataTransfer.files && e.dataTransfer.files.length) {
        addFiles(e.dataTransfer.files);
      }
    });
    document.getElementById('file-input').addEventListener('change', (e) => {
      addFiles(e.target.files || []);
    });

    backBtn?.addEventListener('click', () => {
      goBack();
    });
    nextBtn?.addEventListener('click', async () => {
      if (stepOrder[currentStepIdx] === 'permission' && !wizardPermission) {
        await ensureUsbPermission();
      }
      if (stepOrder[currentStepIdx] === 'files' && !fileMap.size) {
        log('Add at least one file to continue.');
        return;
      }
      goNext();
    });
    startBtn?.addEventListener('click', async () => {
      if (!wizardPermission) {
        await ensureUsbPermission();
        if (!wizardPermission) return;
      }
      if (!fileMap.size) {
        log('Add required images before flashing.');
        return;
      }
      showStep(stepOrder.indexOf('flash'));
      setFlashControlsEnabled(false);
      flashWizard().catch(err => {
        log(`Error: ${err.message || err}`);
      }).finally(() => {
        if (!successBanner?.classList.contains('show')) setFlashControlsEnabled(true);
      });
    });

    wizFlashBtnBottom?.addEventListener('click', () => {
      document.getElementById('wiz-flash-btn')?.click();
    });
    parseBtnBottom?.addEventListener('click', () => {
      document.getElementById('parse-btn')?.click();
    });
    infoBtnBottom?.addEventListener('click', () => {
      document.getElementById('info-btn')?.click();
    });
    restartBtn?.addEventListener('click', () => {
      window.location.reload();
    });

    // Initialize view
    showStep(0);
  </script>
</body>
</html>
