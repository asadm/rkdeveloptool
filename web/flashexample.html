<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>rkdeveloptool Flash Helper</title>
  <style>
    body { font-family: Arial, sans-serif; max-width: 900px; margin: 2rem auto; line-height: 1.4; }
    button { padding: 0.6rem 1rem; font-size: 1rem; margin-right: 0.4rem; }
    #dropzone { border: 2px dashed #888; padding: 1rem; margin: 1rem 0; text-align: center; }
    pre { background: #f4f4f4; padding: 1rem; min-height: 6rem; white-space: pre-wrap; }
    .file-list { font-family: monospace; }
  </style>
</head>
<body>
  <h1>rkdeveloptool Flash Helper (WebUSB)</h1>
  <p>Drop all extracted images (<code>*.img</code>) plus your loader (<code>*.bin</code>). This tool will parse <code>env.img</code> for the <code>mtdparts</code> string, validate required files, load the loader, flash each partition by LBA, and finally reset the device.</p>

  <h2>Simple wizard</h2>
  <div style="margin-bottom:0.5rem;">
    <button id="wiz-device-btn">Select device (Maskrom/Loader)</button>
    <button id="wiz-flash-btn">Flash device</button>
  </div>

  <div id="dropzone">
    <p>Drop files here or select: <input type="file" id="file-input" multiple></p>
    <div id="files" class="file-list"></div>
  </div>

  <details id="advanced" style="margin-top:1rem;">
    <summary>Advanced controls</summary>
    <div style="margin-top:0.5rem;">
      <button id="request-btn">Grant USB access</button>
      <button id="list-btn">List devices</button>
      <button id="parse-btn">Parse mtdparts</button>
      <button id="load-btn">Load loader</button>
      <button id="info-btn">Read flash info</button>
      <button id="flash-btn">Flash partitions</button>
      <button id="reset-btn">Reset device</button>
    </div>
  </details>

  <pre id="output">Waiting…</pre>

  <script type="module">
    import createModule from './rkDevelopTool_Mac.js';

    const output = document.getElementById('output');
    const filesDiv = document.getElementById('files');
    const modulePromise = createModule({
      noInitialRun: true,
      locateFile: (path) => path.endsWith('.wasm') ? './rkDevelopTool_Mac.wasm' : path
    });

    const requiredImgs = ['env', 'idblock', 'uboot', 'boot', 'oem', 'userdata', 'rootfs'];

    let fileMap = new Map(); // name -> File
    let cachedParts = null;
    let cachedLoader = null;
    let cachedLoaderName = '';
    let wizardPermission = false;
    const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

    const log = (msg) => {
      output.textContent = msg;
      console.log(msg);
    };
    const append = (msg) => {
      output.textContent += '\\n' + msg;
      console.log(msg);
    };

    function normalizeName(file) {
      const base = file.name.toLowerCase();
      return base;
    }

    function refreshFileList() {
      const lines = [];
      for (const [name, f] of fileMap.entries()) {
        lines.push(`${name} (${f.size} bytes)`);
      }
      filesDiv.textContent = lines.join('\\n');
    }

    function addFiles(fileList) {
      for (const f of fileList) {
        fileMap.set(normalizeName(f), f);
      }
      refreshFileList();
    }

    async function readFileAsUint8Array(file) {
      const buf = await file.arrayBuffer();
      return new Uint8Array(buf);
    }

    function parseSize(numStr, unit) {
      const n = parseInt(numStr, 10);
      const u = unit ? unit.toUpperCase() : '';
      if (u === 'G') return n * 1024 * 1024 * 1024;
      if (u === 'M') return n * 1024 * 1024;
      if (u === 'K') return n * 1024;
      return n;
    }

    function findMtdpartsString(data) {
      // Decode as Latin-1 to preserve byte-for-byte text without dropping high-bit chars.
      const raw = new TextDecoder('latin1', { fatal: false }).decode(data);
      let m = raw.match(/mtdparts=[^\s\x00"']+/i);
      if (m) {
        console.log('Found mtdparts (latin1) at offset', raw.toLowerCase().indexOf('mtdparts'));
        return m[0];
      }
      console.log('latin1 scan: no mtdparts');
      // Fallback: UTF-16LE in case the string is wide.
      const dv = new DataView(data.buffer, data.byteOffset, data.byteLength);
      let utf16 = '';
      for (let i = 0; i + 1 < data.length; i += 2) {
        const code = dv.getUint16(i, true);
        utf16 += (code >= 0x20 && code <= 0x7e) ? String.fromCharCode(code) : ' ';
      }
      m = utf16.match(/mtdparts=[^\s"]+/i);
      if (m) {
        console.log('Found mtdparts (utf16le)');
        return m[0];
      }
      console.log('UTF16 scan: no mtdparts');
      return null;
    }

    function parseMtdparts(str) {
      const m = str.match(/mtdparts=([^\s]+)/i);
      if (!m) return null;
      const spec = m[1];
      const colon = spec.indexOf(':');
      if (colon === -1) return null;
      const partsSpec = spec.slice(colon + 1);
      const entries = partsSpec.split(',');
      const partitions = [];
      let currentOffset = 0;
      for (const entry of entries) {
        const match = entry.match(/([0-9]+)([KMG]?)(?:@([0-9]+)([KMG]?))?\(([^)]+)\)/i);
        if (!match) continue;
        const sizeBytes = parseSize(match[1], match[2]);
        const hasOffset = typeof match[3] !== 'undefined' && match[3] !== '';
        const offsetBytes = hasOffset ? parseSize(match[3], match[4]) : currentOffset;
        const name = match[5];
        const startLba = Math.floor(offsetBytes / 512);
        const sizeLba = Math.floor((sizeBytes + 511) / 512);
        partitions.push({ name, startLba, sizeLba });
        currentOffset = Math.max(currentOffset, offsetBytes + sizeBytes);
      }
      return partitions;
    }

    async function extractPartitions() {
      const envFile = [...fileMap.values()].find(f => normalizeName(f).includes('env'));
      if (!envFile) throw new Error('env.img not provided.');
      const data = await readFileAsUint8Array(envFile);
      console.log(`Scanning ${envFile.name} (${data.length} bytes) for mtdparts`);
      const mtdpartsStr = findMtdpartsString(data);
      if (mtdpartsStr) {
        const parts = parseMtdparts(mtdpartsStr);
        if (parts && parts.length) {
          append(`Found mtdparts in ${envFile.name}`);
          return parts;
        }
      }
      return null;
    }

    function findLoader() {
      const binFiles = [...fileMap.values()].filter(f => f.name.toLowerCase().endsWith('.bin'));
      return binFiles[0] || null;
    }

    async function ensureLoaderBuffer() {
      if (cachedLoader) return { data: cachedLoader, name: cachedLoaderName };
      const loader = findLoader();
      if (!loader) throw new Error('Missing loader (.bin)');
      cachedLoaderName = loader.name;
      cachedLoader = await readFileAsUint8Array(loader);
      return { data: cachedLoader, name: cachedLoaderName };
    }

    function findImageForName(name) {
      const lower = name.toLowerCase();
      for (const [key, f] of fileMap.entries()) {
        if (key.includes(`${lower}.img`)) return f;
        if (key === `${lower}`) return f;
      }
      return null;
    }

    async function ensureParts() {
      if (cachedParts) return cachedParts;
      const parts = await extractPartitions();
      if (!parts) throw new Error('Failed to locate mtdparts in provided files.');
      cachedParts = parts;
      return parts;
    }

    async function waitForDevice(Module, allowed = ['loader', 'maskrom'], retries = 12, delayMs = 500) {
      for (let i = 0; i < retries; i++) {
        try {
          const raw = await Module.listDevicesJs();
          const devices = Array.from(raw || []);
          const loader = devices.find((d) => allowed.includes((d.type || '').toLowerCase()));
          if (loader) return loader;
        } catch (_) {}
        await sleep(delayMs);
      }
      return false;
    }

    async function ensureUsbPermission() {
      try {
        const allowed = await navigator.usb.getDevices();
        if (allowed.some(d => d.vendorId === 0x2207 || d.vendorId === 0x071B)) {
          wizardPermission = true;
          return true;
        }
      } catch (_) {}
      try {
        await navigator.usb.requestDevice({ filters: [{ vendorId: 0x2207 }, { vendorId: 0x071B }] });
        wizardPermission = true;
        return true;
      } catch (err) {
        log(`Permission denied or error: ${err.message || err}`);
        return false;
      }
    }

    async function flashWizard() {
      log('Starting flash wizard…');
      const Module = await modulePromise;

      const okPerm = await ensureUsbPermission();
      if (!okPerm) return;

      const missing = [];
      for (const r of requiredImgs) {
        if (!findImageForName(r)) missing.push(r);
      }
      if (missing.length) {
        log(`Missing required images: ${missing.join(', ')}`);
        return;
      }
      let loaderBuf;
      let loaderName;
      try {
        const loader = await ensureLoaderBuffer();
        loaderBuf = loader.data;
        loaderName = loader.name;
      } catch (err) {
        log(err.message || String(err));
        return;
      }

      let parts;
      try {
        parts = await ensureParts();
      } catch (err) {
        log(err.message || String(err));
        return;
      }
      const needed = requiredImgs.filter(n => parts.find(p => p.name.toLowerCase() === n));
      append(`Found mtdparts: ${parts.map(p => `${p.name}@${p.startLba}`).join(', ')}`);

      try {
        let info = await Module.readFlashInfo();
        if (!info || info.flashSizeMiB === undefined) {
          append('ReadFlashInfo empty; attempting to load loader…');
          append(`Loading loader ${loaderName}…`);
          const dlOk = await Module.downloadBootBuffer(loaderBuf);
          if (!dlOk) {
            log('downloadBoot failed. Aborting.');
            return;
          }
          append('Loader loaded, waiting for device to enumerate…');
          const dev = await waitForDevice(Module, ['loader', 'maskrom'], 20, 500);
          if (!dev) {
            log('Loader loaded but device not detected.');
            return;
          }
          append(`Device present (${dev.type}).`);
          info = await Module.readFlashInfo();
        }
        if (info && info.flashSizeMiB !== undefined) {
          append(`FlashInfo: manufacturer=${info.manufacturer} size=${info.flashSizeMiB}MiB`);
        } else {
          log('ReadFlashInfo returned empty result. Aborting.');
          return;
        }
      } catch (err) {
        log(`ReadFlashInfo failed (${err?.message || err}). Aborting.`);
        return;
      }

      for (const part of parts) {
        const nameLower = part.name.toLowerCase();
        const f = findImageForName(nameLower);
        if (!f) {
          append(`Skipping ${part.name} (no matching image).`);
          continue;
        }
        if (!needed.includes(nameLower)) {
          append(`Skipping ${part.name} (not in required list).`);
          continue;
        }
        const data = await readFileAsUint8Array(f);
        append(`Writing ${part.name} (${data.byteLength} bytes) @ LBA ${part.startLba}…`);
        try {
          const ok = await Module.writeLba(part.startLba, data);
          if (!ok) {
            log(`WriteLBA failed for ${part.name}. Aborting.`);
            return;
          }
        } catch (err) {
          log(`WriteLBA threw for ${part.name}: ${err?.message || err}. Aborting.`);
          return;
        }
      }

      append('Issuing reset…');
      try {
        const ok = await Module.resetDevice(0);
        append(ok ? 'ResetDevice sent.' : 'ResetDevice failed.');
      } catch (err) {
        append(`ResetDevice error: ${err}`);
      }
      append('Flash sequence complete.');
    }

    async function flashAll() {
      log('Loading WASM…');
      const Module = await modulePromise;

      // Validate files
      const missing = [];
      for (const r of requiredImgs) {
        if (!findImageForName(r)) missing.push(r);
      }
      if (missing.length) {
        log(`Missing required images: ${missing.join(', ')}`);
        return;
      }
      let parts;
      try {
        parts = await ensureParts();
      } catch (err) {
        log(err.message || String(err));
        return;
      }
      const needed = requiredImgs.filter(n => parts.find(p => p.name.toLowerCase() === n));
      append(`Found mtdparts: ${parts.map(p => `${p.name}@${p.startLba}`).join(', ')}`);

      // Require an already-loaded device (loader or maskrom)
      const dev = await waitForDevice(Module, ['loader', 'maskrom'], 20, 500);
      if (!dev) {
        log('No Loader/Maskrom device detected. Load the loader first.');
        return;
      }
      append(`Using detected device (${dev.type}).`);

      // Probe flash info (mandatory)
      try {
        const info = await Module.readFlashInfo();
        if (info && info.flashSizeMiB !== undefined) {
          append(`FlashInfo: manufacturer=${info.manufacturer} size=${info.flashSizeMiB}MiB`);
        } else {
          log('ReadFlashInfo returned empty result. Aborting.');
          return;
        }
      } catch (err) {
        log(`ReadFlashInfo failed (${err?.message || err}). Aborting.`);
        return;
      }

      // Flash partitions
      for (const part of parts) {
        const nameLower = part.name.toLowerCase();
        const f = findImageForName(nameLower);
        if (!f) {
          append(`Skipping ${part.name} (no matching image).`);
          continue;
        }
        if (!needed.includes(nameLower)) {
          append(`Skipping ${part.name} (not in required list).`);
          continue;
        }
        const data = await readFileAsUint8Array(f);
        append(`Writing ${part.name} (${data.byteLength} bytes) @ LBA ${part.startLba}…`);
        try {
          const ok = await Module.writeLba(part.startLba, data);
          if (!ok) {
            log(`WriteLBA failed for ${part.name}. Aborting.`);
            return;
          }
        } catch (err) {
          log(`WriteLBA threw for ${part.name}: ${err?.message || err}. Aborting.`);
          return;
        }
      }

      // Reset
      append('Issuing reset…');
      try {
        const ok = await Module.resetDevice(0);
        append(ok ? 'ResetDevice sent.' : 'ResetDevice failed.');
      } catch (err) {
        append(`ResetDevice error: ${err}`);
      }
      append('Flash sequence complete.');
    }

    document.getElementById('wiz-device-btn').addEventListener('click', async () => {
      await ensureUsbPermission();
      if (wizardPermission) log('Permission granted (or already granted). Ready to flash.');
    });

    document.getElementById('wiz-flash-btn').addEventListener('click', () => {
      flashWizard().catch(err => {
        log(`Error: ${err.message || err}`);
      });
    });

    document.getElementById('request-btn').addEventListener('click', async () => {
      try {
        await navigator.usb.requestDevice({ filters: [{ vendorId: 0x2207 }, { vendorId: 0x071B }] });
        log('Permission granted (or already granted).');
      } catch (err) {
        log(`Permission denied or error: ${err.message || err}`);
      }
    });

    document.getElementById('list-btn').addEventListener('click', async () => {
      log('Loading WASM…');
      const Module = await modulePromise;
      try {
        const raw = await Module.listDevicesJs();
        const devices = Array.from(raw || []);
        if (!devices.length) {
          log('No Rockchip devices found (ensure permission).');
          return;
        }
        const lines = devices.map(d => `DevNo=${d.devNo} Vid=0x${d.vid.toString(16)} Pid=0x${d.pid.toString(16)} LocationID=${d.locationId} ${d.type}`);
        log(lines.join('\\n'));
      } catch (err) {
        log(`Error: ${err}`);
      }
    });

    document.getElementById('flash-btn').addEventListener('click', () => {
      flashAll().catch(err => {
        log(`Error: ${err.message || err}`);
      });
    });

    document.getElementById('parse-btn').addEventListener('click', async () => {
      try {
        const parts = await ensureParts();
        log(`Parsed mtdparts: ${parts.map(p => `${p.name}@${p.startLba}`).join(', ')}`);
      } catch (err) {
        log(`Parse failed: ${err.message || err}`);
      }
    });

    document.getElementById('load-btn').addEventListener('click', async () => {
      log('Loading WASM…');
      const Module = await modulePromise;
      try {
        const loader = await ensureLoaderBuffer();
        append(`Loading loader ${loader.name}…`);
        const ok = await Module.downloadBootBuffer(loader.data);
        if (!ok) {
          log('Loader load failed.');
          return;
        }
        const dev = await waitForDevice(Module, ['loader', 'maskrom'], 20, 500);
        log(dev ? `Device present (${dev.type}).` : 'Loader loaded but device not detected.');
      } catch (err) {
        log(err.message || String(err));
      }
    });

    document.getElementById('info-btn').addEventListener('click', async () => {
      log('Loading WASM…');
      const Module = await modulePromise;
      try {
        const info = await Module.readFlashInfo();
        if (info && info.flashSizeMiB !== undefined) {
          log(`FlashInfo: manufacturer=${info.manufacturer} size=${info.flashSizeMiB}MiB`);
        } else {
          log('ReadFlashInfo returned empty result.');
        }
      } catch (err) {
        log(`ReadFlashInfo failed: ${err.message || err}`);
      }
    });

    document.getElementById('reset-btn').addEventListener('click', async () => {
      log('Loading WASM…');
      const Module = await modulePromise;
      try {
        const ok = await Module.resetDevice(0);
        log(ok ? 'ResetDevice sent.' : 'ResetDevice failed.');
      } catch (err) {
        log(`ResetDevice failed: ${err.message || err}`);
      }
    });

    const dropzone = document.getElementById('dropzone');
    dropzone.addEventListener('dragover', (e) => {
      e.preventDefault();
      dropzone.style.borderColor = '#444';
    });
    dropzone.addEventListener('dragleave', (e) => {
      e.preventDefault();
      dropzone.style.borderColor = '#888';
    });
    dropzone.addEventListener('drop', (e) => {
      e.preventDefault();
      dropzone.style.borderColor = '#888';
      if (e.dataTransfer.files && e.dataTransfer.files.length) {
        addFiles(e.dataTransfer.files);
      }
    });
    document.getElementById('file-input').addEventListener('change', (e) => {
      addFiles(e.target.files || []);
    });
  </script>
</body>
</html>
