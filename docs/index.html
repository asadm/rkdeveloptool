<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>rkdeveloptool Flash Helper</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="description" content="Flash Rockchip boards from the browser with rkDevelopTool compiled to WebUSB-enabled WASM." />
  <meta property="og:title" content="rkdeveloptool Flash Helper" />
  <meta property="og:description" content="Flash Rockchip boards from the browser with rkDevelopTool compiled to WebUSB-enabled WASM." />
  <meta property="og:type" content="website" />
  <meta property="og:url" content="https://asadmemon.com/rkdeveloptool/" />
  <meta property="og:image" content="https://asadmemon.com/rkdeveloptool/preview.png" />
  <meta property="og:image:alt" content="rkdeveloptool WebUSB flashing wizard preview" />
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:title" content="rkdeveloptool Flash Helper" />
  <meta name="twitter:description" content="Flash Rockchip boards from the browser with rkDevelopTool compiled to WebUSB-enabled WASM." />
  <meta name="twitter:image" content="https://asadmemon.com/rkdeveloptool/preview.png" />
  <meta name="twitter:image:alt" content="rkdeveloptool WebUSB flashing wizard preview" />
  <link rel="stylesheet" href="https://unpkg.com/98.css" />
  <style>
    :root {
      --win98-bg: #008080;
    }
    * {
      box-sizing: border-box;
    }
    body {
      margin: 0;
      min-height: 100vh;
      background: var(--win98-bg);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 12px;
      padding: 16px;
      font-family: "MS Sans Serif", "Microsoft Sans Serif", Arial, sans-serif;
    }
    .wizard-window,
    .info-window {
      width: 860px;
      max-width: calc(100vw - 20px);
    }
    .info-window .window-body {
      background: #d8d8d8;
    }
    .info-browser {
      border: 1px solid #b4b4b4;
      background: #fff;
      box-shadow: inset 0 1px 0 #f8f8f8;
    }
    .info-toolbar {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px 8px;
      background: linear-gradient(#f4f4f4, #e5e5e5);
      border-bottom: 1px solid #b4b4b4;
    }
    .info-badge {
      width: 16px;
      height: 16px;
      border: 1px solid #9a9a9a;
      background: linear-gradient(#fff, #c9e3ff);
    }
    .info-address {
      flex: 1;
      padding: 4px 6px;
      border: 1px solid #9a9a9a;
      background: #fff;
      font-family: "MS Sans Serif", "Microsoft Sans Serif", Arial, sans-serif;
      font-size: 12px;
      color: #333;
    }
    .info-content {
      padding: 12px 14px 16px;
      background: #fff;
      font-family: Georgia, "Times New Roman", serif;
      font-size: 15px;
      line-height: 1.6;
      color: #111;
    }
    .info-content pre {
      background: #f7f7f7;
      border: 1px solid #d0d0d0;
      padding: 10px 12px;
      overflow: auto;
      max-width: 100%;
    }
    .info-content code {
      font-family: Menlo, Consolas, "Courier New", monospace;
      font-size: 13px;
    }
    .info-media-row {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      margin: 8px 0 14px;
      align-items: flex-start;
    }
    .info-media-row img,
    .info-media-row iframe {
      flex: 1 1 320px;
      max-width: 100%;
      border: 1px solid #d0d0d0;
    }
    .info-media-row iframe {
      min-height: 220px;
      background: #000;
    }
    .info-media-row a {
      display: block;
      line-height: 0;
    }
    .info-content h4 {
      margin: 8px 0 4px;
      font-size: 17px;
    }
    .info-content p {
      margin: 0 0 10px;
    }
    .info-content ul {
      margin: 0 0 12px 18px;
      padding: 0;
    }
    .info-window.hidden {
      display: none;
    }
    .wizard-body {
      display: grid;
      grid-template-columns: 220px 1fr;
      gap: 12px;
      align-items: start;
    }
    .wizard-steps {
      padding: 12px;
    }
    .wizard-steps h4 {
      margin: 0 0 8px;
      font-size: 14px;
    }
    .wizard-steps ol {
      margin: 0;
      padding-left: 18px;
    }
    .wizard-steps li {
      margin-bottom: 8px;
    }
    .wizard-steps li.active {
      font-weight: bold;
      text-decoration: underline;
    }
    .wizard-steps li.done {
      font-weight: bold;
    }
    .wizard-steps li.done::before {
      content: "✓ ";
      color: #006400;
    }
    .success-banner {
      margin-top: 8px;
      background: #dff0d8;
      border: 1px solid #7db26c;
      padding: 8px;
      display: none;
    }
    .success-banner.show {
      display: block;
    }
    fieldset {
      margin: 0 0 12px;
    }
    legend {
      font-weight: bold;
    }
    .dropzone {
      cursor: pointer;
      text-align: center;
      min-height: 120px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #fff;
    }
    .dropzone:hover {
      background: #e5e5e5;
    }
    .dropzone.active {
      background: #d6d6d6;
    }
    .progress-row {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .progress-indicator {
      flex: 1;
    }
    #progress-label {
      min-width: 160px;
    }
    #progress-steps {
      margin: 8px 0 0;
      padding-left: 18px;
      max-height: 140px;
      overflow: auto;
    }
    #progress-steps li {
      margin-bottom: 4px;
    }
    #progress-steps li.done::before {
      content: "• ";
      font-weight: bold;
    }
    .log-panel {
      padding: 0;
    }
    #output {
      margin: 0;
      padding: 12px;
      white-space: pre-wrap;
      background: #fff;
      max-height: 240px;
      overflow: auto;
    }
    .file-list {
      font-family: monospace;
      white-space: pre-wrap;
    }
    .status-text {
      color: #333;
    }
    .top-actions {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }
    .wizard-step {
      margin: 0 0 12px;
    }
    .wizard-step.hidden {
      display: none;
    }
    .wizard-nav {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      margin-top: 4px;
    }
    .wizard-nav-right {
      display: flex;
      gap: 8px;
    }
    @media (max-width: 760px) {
      body {
        align-items: flex-start;
      }
      .wizard-body {
        grid-template-columns: 1fr;
      }
      .wizard-window,
      .info-window {
        width: 100%;
      }
    }
  </style>
</head>
<body>
  <div class="window wizard-window">
    <div class="title-bar">
      <div class="title-bar-text">rkdeveloptool Flash Wizard</div>
      <div class="title-bar-controls">
        <button aria-label="Minimize"></button>
        <button aria-label="Maximize"></button>
        <button aria-label="Close"></button>
      </div>
    </div>
    <div class="window-body">
      <div class="wizard-body">
        <aside class="sunken-panel wizard-steps">
          <h4>Setup wizard</h4>
          <ol id="step-list">
            <li data-step="permission">Connect to device</li>
            <li data-step="files">Drop images</li>
            <li data-step="flash">Flash progress</li>
          </ol>
        </aside>
        <div class="wizard-main">
          <fieldset class="wizard-step" data-step="permission">
            <legend>1. Connect</legend>
            <p class="status-text" id="connect-status">Waiting for USB permission…</p>
            <div class="field-row top-actions">
              <button id="wiz-device-btn">Select device (Maskrom/Loader)</button>
              <button id="list-btn">List devices</button>
            </div>
          </fieldset>

          <fieldset class="wizard-step hidden" data-step="files">
            <legend>2. Add images</legend>
            <p class="status-text" id="file-status">Drop images or choose them manually.</p>
            <div id="dropzone" class="field-border dropzone">
              <p>Drop files here or select: <input type="file" id="file-input" multiple></p>
            </div>
            <div class="field-border" style="margin-top: 8px;">
              <strong>Files:</strong>
              <div id="files" class="file-list"></div>
            </div>
          </fieldset>

          <fieldset class="wizard-step hidden" data-step="flash">
            <legend>3. Flash</legend>
            <div class="field-row top-actions">
              <button class="default" id="wiz-flash-btn">Flash device</button>
              <button id="parse-btn">Parse mtdparts</button>
              <button id="info-btn">Read flash info</button>
            </div>
            <div class="progress-row" style="margin-top: 8px;">
              <span id="progress-label">Waiting…</span>
              <div class="progress-indicator segmented">
                <span class="progress-indicator-bar" id="progress-bar" style="width: 0%;"></span>
              </div>
            </div>
            <ol id="progress-steps" class="sunken-panel" style="padding: 8px 12px; margin-top: 8px;"></ol>
            <div class="field-row top-actions" style="justify-content: flex-end; margin-top: 8px;">
              <button class="default" id="wiz-flash-btn-bottom">Flash device</button>
              <button id="parse-btn-bottom">Parse mtdparts</button>
              <button id="info-btn-bottom">Read flash info</button>
            </div>
            <div id="success-banner" class="success-banner">
              Flash complete! <button id="restart-btn">Start over</button>
            </div>
          </fieldset>

          <details id="advanced" style="margin-top: 0.5rem;">
            <summary>Advanced controls</summary>
            <div class="field-row" style="margin-top: 0.5rem; flex-wrap: wrap; gap: 8px;">
              <button id="request-btn">Grant USB access</button>
              <button id="load-btn">Load loader</button>
              <button id="flash-btn">Flash partitions</button>
              <button id="reset-btn">Reset device</button>
            </div>
          </details>

          <div class="sunken-panel log-panel" style="margin-top: 12px;">
            <div class="status-field-border" style="padding: 4px 8px; background: #c0c0c0;">
              Wizard output
            </div>
            <pre id="output">Waiting…</pre>
          </div>
          <div class="wizard-nav">
            <button id="back-btn">Back</button>
            <div class="wizard-nav-right">
              <button id="next-btn">Next</button>
              <button class="default" id="start-btn">Start flash</button>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="window info-window" id="info-window">
    <div class="title-bar">
      <div class="title-bar-text">What is this?</div>
      <div class="title-bar-controls">
        <button aria-label="Minimize"></button>
        <button aria-label="Maximize"></button>
        <button aria-label="Close"></button>
      </div>
    </div>
    <div class="window-body">
        <div class="info-browser">
          <div class="info-toolbar">
            <div class="info-badge"></div>
            <div class="info-address">https://github.com/asadm/rkdeveloptool</div>
          </div>
          <div class="info-content">
          <h4><a href="https://github.com/asadm/rkdeveloptool" target="_blank" rel="noreferrer noopener">rkDevelopTooljs: Rockchip flashing in the browser</a></h4>
          <p><code>rkDevelopTool</code> ported to WASM via libusb's WebUSB backend; runs entirely in the browser. Tested with Luckfox boards and custom PCBs with RV1103 and RV1106 from empty flash to a fully booting system using only the browser. Should work with any Rockchip SoC supported by rkDevelopTool. Load the page, connect your device in Maskrom mode (usually hold boot and connect to USB), and follow the wizard. All exported WASM APIs are async (Asyncify-instrumented). Always <code>await</code> calls before reading results.</p>
          <p>Requires a Chrome-based browser with WebUSB enabled; see <a href="https://caniuse.com/webusb" target="_blank" rel="noreferrer noopener">caniuse.com/webusb</a>.</p>

          <div class="info-media-row">
            <iframe width="100%" height="400" src="https://www.youtube.com/embed/wphVfUbxc6o?si=WjXhA4HJJkVeBBLc" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
          </div>

          <h4>Why</h4>
          <p>I wanted an easy way for users of my <a href="https://x.com/_asadmemon/status/1989417143398797424" target="_blank" rel="noreferrer noopener">Embedded SLAM Camera</a> to flash their boards without installing software. This project is a step towards that goal.</p>

          <h4>Working APIs</h4>
          <ul>
            <li><code>await Module.listDevicesJs()</code>: returns an array of <code>{ devNo, vid, pid, locationId, type }</code> for Maskrom/Loader/MSC devices.</li>
            <li><code>await Module.downloadBootBuffer(uint8Array) -&gt; bool</code>: sends a loader to a Maskrom device; accepts a <code>Uint8Array</code> of the loader.</li>
            <li><code>await Module.readFlashInfo() -&gt; { manufacturer, flashSizeMiB, blockSize, pageSize, blockCount, eccBits, accessTime, flashCs, validSectorsPerBlock } | null</code>: probes flash info (requires Loader/Maskrom).</li>
            <li><code>await Module.readFlashId() -&gt; Uint8Array | null</code>: reads the flash ID.</li>
            <li><code>await Module.readChipInfo() -&gt; Uint8Array | null</code>: reads chip info.</li>
            <li><code>await Module.readCapability() -&gt; { directLba, first4mAccess, rawFlag } | null</code>: reads device capabilities.</li>
            <li><code>await Module.printPartitions() -&gt; Array&lt;{ index, startLba, name }&gt;</code>: reads partition table (GPT) if available.</li>
            <li><code>await Module.writeLba(beginSector: number, data: Uint8Array) -&gt; bool</code>: writes data starting at LBA; uses chunked transfers internally.</li>
            <li><code>await Module.eraseFlash() -&gt; bool</code>: erases the entire flash (dangerous).</li>
            <li><code>await Module.resetDevice(subcode: number) -&gt; bool</code>: resets the device with a subcode (commonly <code>0</code>).</li>
            <li><code>await Module.testDevice() -&gt; bool</code>: basic connectivity test.</li>
          </ul>

          <h4>Minimal usage example</h4>
          <pre><code>import createModule from './rkDevelopTool_Mac.js';

const Module = await createModule({ noInitialRun: true });
await navigator.usb.requestDevice({ filters: [{ vendorId: 0x2207 }, { vendorId: 0x071B }] });
const devs = await Module.listDevicesJs();
console.log('Devices:', Array.from(devs || []));

const loaderData = await fetch('/path/to/loader.bin').then(r =&gt; r.arrayBuffer()).then(buf =&gt; new Uint8Array(buf));
const okBoot = await Module.downloadBootBuffer(loaderData);
if (!okBoot) throw new Error('downloadBootBuffer failed');

const info = await Module.readFlashInfo();
console.log('Flash info:', info);</code></pre>

          <h4>TODO / unverified</h4>
          <ul>
            <li><code>Module.downloadBoot(pathString)</code>: file-path based loader download (expects a writable FS path); use <code>downloadBootBuffer</code> in the browser instead.</li>
            <li><code>Module.listDevices()</code>: legacy C++ vector return; <code>listDevicesJs</code> is preferred for JS.</li>
            <li>Additional helpers (read LBA, partial erase, progress callbacks) could be layered on top of existing primitives.</li>
          </ul>

          <h4>License</h4>
          <ul>
            <li>WASM parts (wasm_api.cpp, web/) licensed under the Apache License, Version 2.0.</li>
            <li>rkDevelopTool originally licensed under GNU General Public License.</li>
            <li>libusb licensed under GNU LESSER GENERAL PUBLIC LICENSE Version 2.1.</li>
          </ul>
          </div>
        </div>
      </div>
  </div>

  <script type="module">
    import createModule from './rkDevelopTool_Mac.js';

    const output = document.getElementById('output');
    const filesDiv = document.getElementById('files');
    const progressBar = document.getElementById('progress-bar');
    const progressLabel = document.getElementById('progress-label');
    const progressSteps = document.getElementById('progress-steps');
    const stepList = document.getElementById('step-list');
    const connectStatus = document.getElementById('connect-status');
    const fileStatus = document.getElementById('file-status');
    const backBtn = document.getElementById('back-btn');
    const nextBtn = document.getElementById('next-btn');
    const startBtn = document.getElementById('start-btn');
    const wizFlashBtnBottom = document.getElementById('wiz-flash-btn-bottom');
    const parseBtnBottom = document.getElementById('parse-btn-bottom');
    const infoBtnBottom = document.getElementById('info-btn-bottom');
    const successBanner = document.getElementById('success-banner');
    const restartBtn = document.getElementById('restart-btn');
    const wizardSteps = document.querySelectorAll('.wizard-step');
    const infoWindow = document.getElementById('info-window');
    const modulePromise = createModule({
      noInitialRun: true,
      locateFile: (path) => path.endsWith('.wasm') ? './rkDevelopTool_Mac.wasm' : path
    });

    const requiredImgs = ['env', 'idblock', 'uboot', 'boot', 'oem', 'userdata', 'rootfs'];

    let fileMap = new Map(); // name -> File
    let cachedParts = null;
    let cachedLoader = null;
    let cachedLoaderName = '';
    let wizardPermission = false;
    let progressTotal = 1;
    let progressDone = 0;
    let currentStepIdx = 0;
    const stepOrder = ['permission', 'files', 'flash'];
    const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

    const log = (msg) => {
      output.textContent = msg;
      console.log(msg);
      scrollLogs();
    };
    const append = (msg) => {
      output.textContent += '\n' + msg;
      console.log(msg);
      scrollLogs();
    };

    function setStepDone(step, done = true) {
      const el = stepList?.querySelector(`[data-step="${step}"]`);
      if (el) el.classList.toggle('done', done);
    }

    function setStepActive(step) {
      stepList?.querySelectorAll('li').forEach((li) => {
        li.classList.toggle('active', li.dataset.step === step);
      });
    }

    function showStep(idx) {
      currentStepIdx = Math.min(Math.max(idx, 0), stepOrder.length - 1);
      wizardSteps.forEach((el, i) => {
        el.classList.toggle('hidden', i !== currentStepIdx);
      });
      setStepActive(stepOrder[currentStepIdx]);
      if (infoWindow) infoWindow.classList.toggle('hidden', currentStepIdx !== 0);
      updateNavButtons();
    }

    function updateConnectStatus(text, done = false) {
      if (connectStatus) connectStatus.textContent = text;
      setStepDone('permission', done);
      updateNavButtons();
    }

    function updateFileStatus() {
      if (fileStatus) {
        if (fileMap.size) {
          fileStatus.textContent = `${fileMap.size} file(s) ready.`;
          setStepDone('files', true);
        } else {
          fileStatus.textContent = 'Drop images or choose them manually.';
          setStepDone('files', false);
        }
      }
      updateNavButtons();
    }

    function resetProgress(total = 1, label = 'Waiting…') {
      progressTotal = Math.max(1, total);
      progressDone = 0;
      if (progressBar) progressBar.style.width = '0%';
      if (progressLabel) progressLabel.textContent = label;
      if (progressSteps) progressSteps.innerHTML = '';
      if (successBanner) successBanner.classList.remove('show');
    }

    function bumpTotalSteps(extra = 1) {
      progressTotal = Math.max(1, progressTotal + extra);
    }

    function completeProgress(label) {
      progressDone += 1;
      const pct = Math.min(100, Math.round((progressDone / progressTotal) * 100));
      if (progressBar) progressBar.style.width = `${pct}%`;
      if (progressLabel) progressLabel.textContent = label || `${pct}% complete`;
      if (progressSteps) {
        const li = document.createElement('li');
        li.textContent = label || `Step ${progressDone}`;
        li.classList.add('done');
        progressSteps.appendChild(li);
      }
      scrollLogs();
    }

    function normalizeName(file) {
      const base = file.name.toLowerCase();
      return base;
    }

    function refreshFileList() {
      const lines = [];
      for (const [name, f] of fileMap.entries()) {
        lines.push(`${name} (${f.size} bytes)`);
      }
      filesDiv.textContent = lines.join('\n');
      updateFileStatus();
    }

    function addFiles(fileList) {
      for (const f of fileList) {
        fileMap.set(normalizeName(f), f);
      }
      refreshFileList();
    }

    async function readFileAsUint8Array(file) {
      const buf = await file.arrayBuffer();
      return new Uint8Array(buf);
    }

    function parseSize(numStr, unit) {
      const n = parseInt(numStr, 10);
      const u = unit ? unit.toUpperCase() : '';
      if (u === 'G') return n * 1024 * 1024 * 1024;
      if (u === 'M') return n * 1024 * 1024;
      if (u === 'K') return n * 1024;
      return n;
    }

    function findMtdpartsString(data) {
      // Decode as Latin-1 to preserve byte-for-byte text without dropping high-bit chars.
      const raw = new TextDecoder('latin1', { fatal: false }).decode(data);
      let m = raw.match(/(?:mtdparts|blkdevparts)=[^\s\x00"']+/i);
      if (m) {
        const off = raw.toLowerCase().search(/(?:mtdparts|blkdevparts)/);
        console.log('Found mtd/blkdev parts (latin1) at offset', off);
        return m[0];
      }
      console.log('latin1 scan: no mtdparts');
      // Fallback: UTF-16LE in case the string is wide.
      const dv = new DataView(data.buffer, data.byteOffset, data.byteLength);
      let utf16 = '';
      for (let i = 0; i + 1 < data.length; i += 2) {
        const code = dv.getUint16(i, true);
        utf16 += (code >= 0x20 && code <= 0x7e) ? String.fromCharCode(code) : ' ';
      }
      m = utf16.match(/(?:mtdparts|blkdevparts)=[^\s"]+/i);
      if (m) {
        console.log('Found mtd/blkdev parts (utf16le)');
        return m[0];
      }
      console.log('UTF16 scan: no mtdparts');
      return null;
    }

    function parseMtdparts(str) {
      const m = str.match(/(?:mtdparts|blkdevparts)=([^\s]+)/i);
      if (!m) return null;
      const spec = m[1];
      const colon = spec.indexOf(':');
      if (colon === -1) return null;
      const partsSpec = spec.slice(colon + 1);
      const entries = partsSpec.split(',');
      const partitions = [];
      let currentOffset = 0;
      for (const entry of entries) {
        const match = entry.match(/([0-9]+)([KMG]?)(?:@([0-9]+)([KMG]?))?\(([^)]+)\)/i);
        if (!match) continue;
        const sizeBytes = parseSize(match[1], match[2]);
        const hasOffset = typeof match[3] !== 'undefined' && match[3] !== '';
        const offsetBytes = hasOffset ? parseSize(match[3], match[4]) : currentOffset;
        const name = match[5];
        const startLba = Math.floor(offsetBytes / 512);
        const sizeLba = Math.floor((sizeBytes + 511) / 512);
        partitions.push({ name, startLba, sizeLba });
        currentOffset = Math.max(currentOffset, offsetBytes + sizeBytes);
      }
      return partitions;
    }

    async function extractPartitions() {
      const envFile = [...fileMap.values()].find(f => normalizeName(f).includes('env'));
      if (!envFile) throw new Error('env.img not provided.');
      const data = await readFileAsUint8Array(envFile);
      console.log(`Scanning ${envFile.name} (${data.length} bytes) for mtdparts`);
      const mtdpartsStr = findMtdpartsString(data);
      if (mtdpartsStr) {
        const parts = parseMtdparts(mtdpartsStr);
        if (parts && parts.length) {
          append(`Found mtdparts in ${envFile.name}`);
          return parts;
        }
      }
      return null;
    }

    function findLoader() {
      const binFiles = [...fileMap.values()].filter(f => f.name.toLowerCase().endsWith('.bin'));
      return binFiles[0] || null;
    }

    async function ensureLoaderBuffer() {
      if (cachedLoader) return { data: cachedLoader, name: cachedLoaderName };
      const loader = findLoader();
      if (!loader) throw new Error('Missing loader (.bin)');
      cachedLoaderName = loader.name;
      cachedLoader = await readFileAsUint8Array(loader);
      return { data: cachedLoader, name: cachedLoaderName };
    }

    function findImageForName(name) {
      const lower = name.toLowerCase();
      for (const [key, f] of fileMap.entries()) {
        if (key.includes(`${lower}.img`)) return f;
        if (key === `${lower}`) return f;
      }
      return null;
    }

    async function ensureParts() {
      if (cachedParts) return cachedParts;
      const parts = await extractPartitions();
      if (!parts) throw new Error('Failed to locate mtdparts in provided files.');
      cachedParts = parts;
      return parts;
    }

    async function listDevicesAndLog(Module) {
      try {
        const raw = await Module.listDevicesJs();
        const devices = Array.from(raw || []);
        if (!devices.length) {
          log('No Rockchip devices found (ensure permission).');
          return;
        }
        const lines = devices.map(d => `DevNo=${d.devNo} Vid=0x${d.vid.toString(16)} Pid=0x${d.pid.toString(16)} LocationID=${d.locationId} ${d.type}`);
        log(lines.join('\n'));
        const first = devices[0];
        if (first && connectStatus) connectStatus.textContent = `Detected device: ${first.type} (Vid=0x${first.vid.toString(16)}, Pid=0x${first.pid.toString(16)})`;
      } catch (err) {
        log(`Error: ${err}`);
      }
    }

    function canAdvanceFrom(step) {
      if (step === 'permission') return wizardPermission;
      if (step === 'files') return fileMap.size > 0;
      return true;
    }

    function updateNavButtons() {
      const atFirst = currentStepIdx === 0;
      const atLast = currentStepIdx === stepOrder.length - 1;
      const currentStep = stepOrder[currentStepIdx];
      if (backBtn) backBtn.disabled = atFirst;
      if (nextBtn) {
        nextBtn.disabled = atLast || !canAdvanceFrom(currentStep);
        nextBtn.hidden = currentStep === 'files';
      }
      if (startBtn) startBtn.disabled = !canAdvanceFrom('files');
    }

    function goNext() {
      const currentStep = stepOrder[currentStepIdx];
      if (!canAdvanceFrom(currentStep)) return;
      if (currentStepIdx < stepOrder.length - 1) {
        showStep(currentStepIdx + 1);
      }
    }

    function goBack() {
      if (currentStepIdx > 0) {
        showStep(currentStepIdx - 1);
      }
    }

    function setFlashControlsEnabled(enabled) {
      const ids = [
        'wiz-flash-btn',
        'parse-btn',
        'info-btn',
        'wiz-flash-btn-bottom',
        'parse-btn-bottom',
        'info-btn-bottom',
        'start-btn',
        'next-btn',
        'back-btn'
      ];
      ids.forEach((id) => {
        const btn = document.getElementById(id);
        if (btn) btn.disabled = !enabled;
      });
    }

    function scrollLogs() {
      if (output) output.scrollTop = output.scrollHeight;
      if (progressSteps) progressSteps.scrollTop = progressSteps.scrollHeight;
    }

    async function waitForDevice(Module, allowed = ['loader', 'maskrom'], retries = 12, delayMs = 500) {
      for (let i = 0; i < retries; i++) {
        try {
          const raw = await Module.listDevicesJs();
          const devices = Array.from(raw || []);
          const loader = devices.find((d) => allowed.includes((d.type || '').toLowerCase()));
          if (loader) return loader;
        } catch (_) {}
        await sleep(delayMs);
      }
      return false;
    }

    async function eraseFlashWithLog(Module) {
      append('Erasing flash…');
      try {
        const ok = await Module.eraseFlash();
        if (!ok) {
          log('Erase flash failed. Aborting.');
          return false;
        }
        append('Erase flash complete.');
        return true;
      } catch (err) {
        log(`Erase flash error: ${err?.message || err}. Aborting.`);
        return false;
      }
    }

    async function ensureUsbPermission() {
      try {
        const allowed = await navigator.usb.getDevices();
        if (allowed.some(d => d.vendorId === 0x2207 || d.vendorId === 0x071B)) {
          wizardPermission = true;
          updateConnectStatus('Permission already granted.', true);
          return true;
        }
      } catch (_) {}
      try {
        await navigator.usb.requestDevice({ filters: [{ vendorId: 0x2207 }, { vendorId: 0x071B }] });
        wizardPermission = true;
        updateConnectStatus('Permission granted.', true);
        return true;
      } catch (err) {
        const msg = `Permission denied or error: ${err.message || err}`;
        log(msg);
        updateConnectStatus(msg, false);
        return false;
      }
    }

    async function flashWizard() {
      log('Starting flash wizard…');
      setStepDone('flash', false);
      const Module = await modulePromise;

      let parts;
      try {
        parts = await ensureParts();
      } catch (err) {
        log(err.message || String(err));
        return;
      }
      const needed = requiredImgs.filter(n => parts.find(p => p.name.toLowerCase() === n));
      const totalSteps = 6 + needed.length + 1; // permission, parse, validate, loader ready, read info, erase, per part, reset
      resetProgress(totalSteps, 'Starting…');
      completeProgress('Parsed mtdparts');

      const okPerm = await ensureUsbPermission();
      if (!okPerm) {
        if (progressLabel) progressLabel.textContent = 'USB permission required.';
        return;
      }
      completeProgress('USB permission granted');

      const missing = [];
      for (const r of requiredImgs) {
        if (!findImageForName(r)) missing.push(r);
      }
      if (missing.length) {
        log(`Missing required images: ${missing.join(', ')}`);
        if (progressLabel) progressLabel.textContent = 'Add required images.';
        return;
      }
      completeProgress('Images validated');

      let loaderBuf;
      let loaderName;
      try {
        const loader = await ensureLoaderBuffer();
        loaderBuf = loader.data;
        loaderName = loader.name;
        completeProgress('Loader ready');
      } catch (err) {
        log(err.message || String(err));
        return;
      }

      let info;
      try {
        info = await Module.readFlashInfo();
        if (!info || info.flashSizeMiB === undefined) {
          bumpTotalSteps(1);
          append('ReadFlashInfo empty; attempting to load loader…');
          append(`Loading loader ${loaderName}…`);
          const dlOk = await Module.downloadBootBuffer(loaderBuf);
          if (!dlOk) {
            log('downloadBoot failed. Aborting.');
            return;
          }
          completeProgress(`Loader ${loaderName} downloaded`);
          append('Loader loaded, waiting for device to enumerate…');
          const dev = await waitForDevice(Module, ['loader', 'maskrom'], 20, 500);
          if (!dev) {
            log('Loader loaded but device not detected.');
            return;
          }
          append(`Device present (${dev.type}).`);
          info = await Module.readFlashInfo();
        }
        if (info && info.flashSizeMiB !== undefined) {
          append(`FlashInfo: manufacturer=${info.manufacturer} size=${info.flashSizeMiB}MiB`);
        } else {
          log('ReadFlashInfo returned empty result. Aborting.');
          return;
        }
      } catch (err) {
        log(`ReadFlashInfo failed (${err?.message || err}). Aborting.`);
        return;
      }
      completeProgress('Flash info read');

      const erased = await eraseFlashWithLog(Module);
      if (!erased) return;
      completeProgress('Erase flash complete');

      for (const part of parts) {
        const nameLower = part.name.toLowerCase();
        const f = findImageForName(nameLower);
        if (!f) {
          append(`Skipping ${part.name} (no matching image).`);
          continue;
        }
        if (!needed.includes(nameLower)) {
          append(`Skipping ${part.name} (not in required list).`);
          continue;
        }
        const data = await readFileAsUint8Array(f);
        append(`Writing ${part.name} (${data.byteLength} bytes) @ LBA ${part.startLba}…`);
        try {
          const ok = await Module.writeLba(part.startLba, data);
          if (!ok) {
            log(`WriteLBA failed for ${part.name}. Aborting.`);
            return;
          }
        } catch (err) {
          log(`WriteLBA threw for ${part.name}: ${err?.message || err}. Aborting.`);
          return;
        }
        completeProgress(`Flashed ${part.name}`);
      }

      append('Issuing reset…');
      try {
        const ok = await Module.resetDevice(0);
        append(ok ? 'ResetDevice sent.' : 'ResetDevice failed.');
      } catch (err) {
        append(`ResetDevice error: ${err}`);
      }
      completeProgress('Reset sent');
      setStepDone('flash', true);
      if (progressLabel) progressLabel.textContent = 'All steps complete';
      append('Flash sequence complete.');
      if (successBanner) successBanner.classList.add('show');
    }

    async function flashAll() {
      log('Loading WASM…');
      const Module = await modulePromise;

      // Validate files
      const missing = [];
      for (const r of requiredImgs) {
        if (!findImageForName(r)) missing.push(r);
      }
      if (missing.length) {
        log(`Missing required images: ${missing.join(', ')}`);
        return;
      }
      let parts;
      try {
        parts = await ensureParts();
      } catch (err) {
        log(err.message || String(err));
        return;
      }
      const needed = requiredImgs.filter(n => parts.find(p => p.name.toLowerCase() === n));
      append(`Found mtdparts: ${parts.map(p => `${p.name}@${p.startLba}`).join(', ')}`);

      // Require an already-loaded device (loader or maskrom)
      const dev = await waitForDevice(Module, ['loader', 'maskrom'], 20, 500);
      if (!dev) {
        log('No Loader/Maskrom device detected. Load the loader first.');
        return;
      }
      append(`Using detected device (${dev.type}).`);

      // Probe flash info (mandatory)
      try {
        const info = await Module.readFlashInfo();
        if (info && info.flashSizeMiB !== undefined) {
          append(`FlashInfo: manufacturer=${info.manufacturer} size=${info.flashSizeMiB}MiB`);
        } else {
          log('ReadFlashInfo returned empty result. Aborting.');
          return;
        }
      } catch (err) {
        log(`ReadFlashInfo failed (${err?.message || err}). Aborting.`);
        return;
      }

      const erased = await eraseFlashWithLog(Module);
      if (!erased) return;

      // Flash partitions
      for (const part of parts) {
        const nameLower = part.name.toLowerCase();
        const f = findImageForName(nameLower);
        if (!f) {
          append(`Skipping ${part.name} (no matching image).`);
          continue;
        }
        if (!needed.includes(nameLower)) {
          append(`Skipping ${part.name} (not in required list).`);
          continue;
        }
        const data = await readFileAsUint8Array(f);
        append(`Writing ${part.name} (${data.byteLength} bytes) @ LBA ${part.startLba}…`);
        try {
          const ok = await Module.writeLba(part.startLba, data);
          if (!ok) {
            log(`WriteLBA failed for ${part.name}. Aborting.`);
            return;
          }
        } catch (err) {
          log(`WriteLBA threw for ${part.name}: ${err?.message || err}. Aborting.`);
          return;
        }
      }

      // Reset
      append('Issuing reset…');
      try {
        const ok = await Module.resetDevice(0);
        append(ok ? 'ResetDevice sent.' : 'ResetDevice failed.');
      } catch (err) {
        append(`ResetDevice error: ${err}`);
      }
      append('Flash sequence complete.');
    }

    document.getElementById('wiz-device-btn').addEventListener('click', async () => {
      const ok = await ensureUsbPermission();
      if (!ok) return;
      const Module = await modulePromise;
      await listDevicesAndLog(Module);
      showStep(stepOrder.indexOf('files'));
    });

    document.getElementById('wiz-flash-btn').addEventListener('click', () => {
      setFlashControlsEnabled(false);
      flashWizard().catch(err => {
        log(`Error: ${err.message || err}`);
      }).finally(() => {
        if (!successBanner?.classList.contains('show')) setFlashControlsEnabled(true);
      });
    });

    document.getElementById('request-btn').addEventListener('click', async () => {
      try {
        await navigator.usb.requestDevice({ filters: [{ vendorId: 0x2207 }, { vendorId: 0x071B }] });
        updateConnectStatus('Permission granted.', true);
        log('Permission granted (or already granted).');
      } catch (err) {
        const msg = `Permission denied or error: ${err.message || err}`;
        updateConnectStatus(msg, false);
        log(msg);
      }
    });

    document.getElementById('list-btn').addEventListener('click', async () => {
      log('Loading WASM…');
      const Module = await modulePromise;
      await listDevicesAndLog(Module);
    });

    document.getElementById('flash-btn').addEventListener('click', () => {
      flashAll().catch(err => {
        log(`Error: ${err.message || err}`);
      });
    });

    document.getElementById('parse-btn').addEventListener('click', async () => {
      try {
        const parts = await ensureParts();
        log(`Parsed mtdparts: ${parts.map(p => `${p.name}@${p.startLba}`).join(', ')}`);
      } catch (err) {
        log(`Parse failed: ${err.message || err}`);
      }
    });

    document.getElementById('load-btn').addEventListener('click', async () => {
      log('Loading WASM…');
      const Module = await modulePromise;
      try {
        const loader = await ensureLoaderBuffer();
        append(`Loading loader ${loader.name}…`);
        const ok = await Module.downloadBootBuffer(loader.data);
        if (!ok) {
          log('Loader load failed.');
          return;
        }
        const dev = await waitForDevice(Module, ['loader', 'maskrom'], 20, 500);
        log(dev ? `Device present (${dev.type}).` : 'Loader loaded but device not detected.');
      } catch (err) {
        log(err.message || String(err));
      }
    });

    document.getElementById('info-btn').addEventListener('click', async () => {
      log('Loading WASM…');
      const Module = await modulePromise;
      try {
        const info = await Module.readFlashInfo();
        if (info && info.flashSizeMiB !== undefined) {
          log(`FlashInfo: manufacturer=${info.manufacturer} size=${info.flashSizeMiB}MiB`);
        } else {
          log('ReadFlashInfo returned empty result.');
        }
      } catch (err) {
        log(`ReadFlashInfo failed: ${err.message || err}`);
      }
    });

    document.getElementById('reset-btn').addEventListener('click', async () => {
      log('Loading WASM…');
      const Module = await modulePromise;
      try {
        const ok = await Module.resetDevice(0);
        log(ok ? 'ResetDevice sent.' : 'ResetDevice failed.');
      } catch (err) {
        log(`ResetDevice failed: ${err.message || err}`);
      }
    });

    const dropzone = document.getElementById('dropzone');
    dropzone.addEventListener('dragover', (e) => {
      e.preventDefault();
      dropzone.classList.add('active');
    });
    dropzone.addEventListener('dragleave', (e) => {
      e.preventDefault();
      dropzone.classList.remove('active');
    });
    dropzone.addEventListener('drop', (e) => {
      e.preventDefault();
      dropzone.classList.remove('active');
      if (e.dataTransfer.files && e.dataTransfer.files.length) {
        addFiles(e.dataTransfer.files);
      }
    });
    document.getElementById('file-input').addEventListener('change', (e) => {
      addFiles(e.target.files || []);
    });

    backBtn?.addEventListener('click', () => {
      goBack();
    });
    nextBtn?.addEventListener('click', async () => {
      if (stepOrder[currentStepIdx] === 'permission' && !wizardPermission) {
        await ensureUsbPermission();
      }
      if (stepOrder[currentStepIdx] === 'files' && !fileMap.size) {
        log('Add at least one file to continue.');
        return;
      }
      goNext();
    });
    startBtn?.addEventListener('click', async () => {
      if (!wizardPermission) {
        await ensureUsbPermission();
        if (!wizardPermission) return;
      }
      if (!fileMap.size) {
        log('Add required images before flashing.');
        return;
      }
      showStep(stepOrder.indexOf('flash'));
      setFlashControlsEnabled(false);
      flashWizard().catch(err => {
        log(`Error: ${err.message || err}`);
      }).finally(() => {
        if (!successBanner?.classList.contains('show')) setFlashControlsEnabled(true);
      });
    });

    wizFlashBtnBottom?.addEventListener('click', () => {
      document.getElementById('wiz-flash-btn')?.click();
    });
    parseBtnBottom?.addEventListener('click', () => {
      document.getElementById('parse-btn')?.click();
    });
    infoBtnBottom?.addEventListener('click', () => {
      document.getElementById('info-btn')?.click();
    });
    restartBtn?.addEventListener('click', () => {
      window.location.reload();
    });

    // Initialize view
    showStep(0);
  </script>
</body>
</html>
